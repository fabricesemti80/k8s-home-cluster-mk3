---
apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: traefik-forward-auth
  namespace: networking
spec:
  interval: 5m
  chart:
    spec:
      # renovate: registryUrl=https://k8s-at-home.com/charts/
      chart: traefik-forward-auth
      version: 1.1.1
      sourceRef:
        kind: HelmRepository
        name: k8s-at-home-charts
        namespace: flux-system
      interval: 5m
  values:
    env:
      TZ: "Europe/London"
    replicaCount: 1
    image:
      repository: "thomseddon/traefik-forward-auth"
      pullPolicy: IfNotPresent
      tag: "1.0.6"
    logging:
      level: debug
      format: "text"
    # authHost: ""
    restrictions:
      # restrictions.domain -- Only allow given email domains. (Comma delimited)
      # domain: ""
      # restrictions.whitelist -- Only allow given email addresses. (Comma delimited)
      whitelist: "${SECRET_CLOUDFLARE_EMAIL}"
    # lifetime -- Lifetime in seconds (default: 43200)
    # lifetime: ""
    cookie:
      # cookie.domain -- Domain(s) to set auth cookie on. (Comma delimited)
      domain: "${SECRET_DOMAIN}"
    default:
      # default.action -- [auth|allow] Default action (default: auth)
      # action: ""
      # default.provider -- [google|oidc|generic-oauth] Default provider (default: google)
      provider: google
    # secret -- Secret used for signing. If empty, one will be generated. If specifying your own in env use "-"
    secret: "${SECRET_TRAEFIK_FORWARD_AUTH_SECRET}"
    middleware:
      # middleware.enabled -- Enable to deploy a preconfigured middleware
      enabled: false
      # middleware.name -- Name for the middleware
      # name: ""
    providers:
      google:
        # providers.google.enabled -- Enable the google provider
        enabled: true
        # providers.google.clientId -- Client ID
        clientId: "${SECRET_GOOGLE_CLIENT_ID}"
        # providers.google.clientSecret -- Client Secret
        clientSecret: "${SECRET_GOOGLE_CLIENT_SECRET}"
        # providers.google.prompt -- Space separated list of OpenID prompt options
        # prompt: ""
    serviceAccount:
      # Specifies whether a service account should be created
      create: true
      # Annotations to add to the service account
      annotations: {}
      # The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      # name: ""
    # livenessProbe -- Liveness probe configuration
    # @default -- {"periodSeconds":20,"tcpSocket":{"port":"http"}}
    livenessProbe:
      # livenessProbe.enabled -- Enable liveness probe
      enabled: true
      tcpSocket:
        port: http
      periodSeconds: 20

    # readinessProbe -- Readiness probe configuration
    # @default -- {"periodSeconds":10,"tcpSocket":{"port":"http"}}
    readinessProbe:
      # readinessProbe.enabled -- Enable readiness probe
      enabled: true
      tcpSocket:
        port: http
      periodSeconds: 10
    service:
      type: ClusterIP
      port: 4181
      ## Provide any additional annotations which may be required. This can be used to
      ## set the LoadBalancer service type to internal only.
      ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
      ##
      annotations: {}
      labels: {}
      additionalSpec: {}
    ingress:
      enabled: true
      ingressClassName: "traefik"
      annotations:
        # ? cert issuer; valid opttions: letsencrypt-stating or letsencrypt-production
        cert-manager.io/cluster-issuer: "letsencrypt-production"
        # ? traefik-specifics
        traefik.ingress.kubernetes.io/router.entrypoints: "websecure"
        #  #? hajimari-specific (optional) - icon ref: https://materialdesignicons.com/
        #  hajimari.io/appName: "hajimari"
        #  hajimari.io/enable: "true"
        #  hajimari.io/icon: "weather-sunset"
        # ? external DNS - if need to be accessed via Internet (using CloudFlare)
        # ? https://github.com/kubernetes-sigs/external-dns/blob/master/docs/faq.md
        external-dns.alpha.kubernetes.io/target: "ipv4.${SECRET_DOMAIN}"
        external-dns/is-public: "true"
      hosts:
        - host: "auth.${SECRET_DOMAIN}"
          paths:
            - path: /
              pathType: Prefix
      tls:
        - hosts:
            - "auth.${SECRET_DOMAIN}"
          secretName: "traefik-forward-auth-tls"
      #  - secretName: chart-example-tls
      #    hosts:
      #      - chart-example.local
    # ingress:
    #   main:
    #     enabled: true
    #     ingressClassName: "traefik"
    #     annotations:
    #       #? cert issuer; valid opttions: letsencrypt-stating or letsencrypt-production
    #       cert-manager.io/cluster-issuer: "letsencrypt-production"
    #       #? traefik-specifics
    #       traefik.ingress.kubernetes.io/router.entrypoints: "websecure"
    #       #? hajimari-specific (optional) - icon ref: https://materialdesignicons.com/
    #       hajimari.io/appName: "hajimari"
    #       hajimari.io/enable: "true"
    #       hajimari.io/icon: "weather-sunset"
    #       #? external DNS - if need to be accessed via Internet (using CloudFlare)
    #       #? https://github.com/kubernetes-sigs/external-dns/blob/master/docs/faq.md
    #       external-dns.alpha.kubernetes.io/target: "ipv4.${SECRET_DOMAIN}"
    #       external-dns/is-public: "true"
    #     hosts:
    #       - host: "hajimari.${SECRET_DOMAIN}"
    #         paths:
    #           - path: /
    #             pathType: Prefix
    #     tls:
    #       - hosts:
    #           - "hajimari.${SECRET_DOMAIN}"
    #         #? needed for ingress!
    #         secretName: "hajimari-tls"
    # persistence:
    #   data:
    #     enabled: true
    #     existingClaim: hajimari-config
    # podAnnotations:
    #   configmap.reloader.stakater.com/reload: "hajimari-settings"
    # resources:
    #   requests:
    #     cpu: 100m
    #     memory: 128Mi
    #   limits:
    #     memory: 256Mi
